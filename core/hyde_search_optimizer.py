#!/usr/bin/env python3
"""
üéØ OPTIMISEUR DE RECHERCHE BAS√â SUR LE SCORING HYDE
Exploite les scores de mots pour optimiser la recherche de documents
"""

import asyncio
import sys
import os
sys.path.append('.')
from typing import Dict, List, Optional, Tuple, Any
from core.hyde_word_scorer import HydeWordScorer
from core.metadata_extractor import MetadataExtractor
import json

class HydeSearchOptimizer:
    """
    Optimiseur de recherche utilisant les scores HyDE pour am√©liorer la pertinence
    """
    
    def __init__(self):
        self.hyde_scorer = HydeWordScorer()
        
    async def optimize_query(self, query: str, company_id: str, sector: str = None) -> Dict[str, Any]:
        """
        Optimise une requ√™te en analysant les scores des mots
        
        Returns:
            Dict avec requ√™te optimis√©e et m√©tadonn√©es de boost
        """
        # 1. Scorer les mots de la requ√™te
        word_scores = await self.hyde_scorer.score_query_words(query, sector)
        
        # 2. Analyser la distribution des scores
        analysis = self._analyze_word_scores(word_scores)
        
        # 3. G√©n√©rer les boosts pour MeiliSearch
        search_boosts = self._generate_search_boosts(word_scores, analysis)
        
        # 4. Cr√©er la requ√™te optimis√©e
        optimized_query = self._build_optimized_query(query, word_scores, analysis)
        
        return {
            "original_query": query,
            "optimized_query": optimized_query,
            "word_scores": word_scores,
            "analysis": analysis,
            "search_boosts": search_boosts,
            "optimization_strategy": self._get_optimization_strategy(analysis)
        }
    
    def _analyze_word_scores(self, word_scores: Dict[str, int]) -> Dict[str, Any]:
        """Analyse la distribution des scores pour d√©terminer la strat√©gie"""
        if not word_scores:
            return {"type": "empty", "confidence": 0}
        
        scores = list(word_scores.values())
        critical_words = [w for w, s in word_scores.items() if s >= 10]
        high_words = [w for w, s in word_scores.items() if s >= 8]
        medium_words = [w for w, s in word_scores.items() if s >= 5]
        low_words = [w for w, s in word_scores.items() if s < 5]
        
        total_words = len(word_scores)
        avg_score = sum(scores) / len(scores) if scores else 0
        max_score = max(scores) if scores else 0
        
        # D√©terminer le type de requ√™te
        if len(critical_words) >= 2:
            query_type = "high_precision"
            confidence = 0.9
        elif len(high_words) >= 1:
            query_type = "balanced"
            confidence = 0.7
        elif len(medium_words) >= 1:
            query_type = "exploratory"
            confidence = 0.5
        else:
            query_type = "generic"
            confidence = 0.3
        
        return {
            "type": query_type,
            "confidence": confidence,
            "total_words": total_words,
            "avg_score": avg_score,
            "max_score": max_score,
            "critical_words": critical_words,
            "high_words": high_words,
            "medium_words": medium_words,
            "low_words": low_words,
            "score_distribution": {
                "10+": len(critical_words),
                "8-9": len([w for w, s in word_scores.items() if 8 <= s < 10]),
                "5-7": len([w for w, s in word_scores.items() if 5 <= s < 8]),
                "0-4": len(low_words)
            }
        }
    
    def _generate_search_boosts(self, word_scores: Dict[str, int], analysis: Dict[str, Any]) -> Dict[str, Any]:
        """G√©n√®re les boosts pour optimiser la recherche MeiliSearch"""
        
        # Boosts bas√©s sur les scores de mots
        word_boosts = {}
        for word, score in word_scores.items():
            if score >= 10:
                word_boosts[word] = 10.0  # Boost maximum
            elif score >= 8:
                word_boosts[word] = 5.0   # Boost √©lev√©
            elif score >= 5:
                word_boosts[word] = 2.0   # Boost mod√©r√©
            else:
                word_boosts[word] = 1.0   # Boost neutre
        
        # Strat√©gie de recherche adapt√©e
        if analysis["type"] == "high_precision":
            strategy = {
                "mode": "precise",
                "searchable_text_boost": 15,
                "content_boost": 8,
                "metadata_boost": 12,
                "typo_tolerance": False,
                "exact_match_priority": True
            }
        elif analysis["type"] == "balanced":
            strategy = {
                "mode": "balanced", 
                "searchable_text_boost": 10,
                "content_boost": 5,
                "metadata_boost": 8,
                "typo_tolerance": True,
                "exact_match_priority": False
            }
        else:
            strategy = {
                "mode": "broad",
                "searchable_text_boost": 8,
                "content_boost": 3,
                "metadata_boost": 5,
                "typo_tolerance": True,
                "exact_match_priority": False
            }
        
        return {
            "word_boosts": word_boosts,
            "strategy": strategy,
            "confidence_multiplier": analysis["confidence"]
        }
    
    def _build_optimized_query(self, original_query: str, word_scores: Dict[str, int], analysis: Dict[str, Any]) -> str:
        """Construit une requ√™te optimis√©e avec boosts int√©gr√©s"""
        
        words = original_query.lower().split()
        optimized_parts = []
        
        for word in words:
            score = word_scores.get(word, 0)
            
            if score >= 10:
                # Mots critiques - boost maximum avec guillemets pour exactitude
                optimized_parts.append(f'"{word}"^10')
            elif score >= 8:
                # Mots tr√®s pertinents - boost √©lev√©
                optimized_parts.append(f"{word}^5")
            elif score >= 5:
                # Mots pertinents - boost mod√©r√©
                optimized_parts.append(f"{word}^2")
            else:
                # Mots normaux - pas de boost
                optimized_parts.append(word)
        
        return " ".join(optimized_parts)
    
    def _get_optimization_strategy(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """D√©termine la strat√©gie d'optimisation recommand√©e"""
        
        strategy_map = {
            "high_precision": {
                "description": "Requ√™te haute pr√©cision avec mots critiques",
                "recommended_actions": [
                    "Prioriser searchable_text avec boost 15x",
                    "D√©sactiver tol√©rance typos",
                    "Forcer correspondance exacte",
                    "Limiter √† 5-10 r√©sultats"
                ],
                "index_priority": ["products", "delivery", "support_paiement"]
            },
            "balanced": {
                "description": "Requ√™te √©quilibr√©e avec bonne pertinence",
                "recommended_actions": [
                    "Boost mod√©r√© searchable_text 10x",
                    "Activer tol√©rance typos",
                    "Recherche dans tous les champs",
                    "Retourner 10-20 r√©sultats"
                ],
                "index_priority": ["products", "delivery", "support_paiement", "company", "location"]
            },
            "exploratory": {
                "description": "Requ√™te exploratoire large",
                "recommended_actions": [
                    "Recherche large tous index",
                    "Boost l√©ger searchable_text 8x",
                    "Tol√©rance typos activ√©e",
                    "Retourner 20+ r√©sultats"
                ],
                "index_priority": ["products", "company", "delivery", "support_paiement", "location"]
            },
            "generic": {
                "description": "Requ√™te g√©n√©rique - recherche large",
                "recommended_actions": [
                    "Recherche full-text standard",
                    "Pas de boost sp√©cial",
                    "Maximum de r√©sultats",
                    "Utiliser reranking"
                ],
                "index_priority": ["company", "products", "delivery", "support_paiement", "location"]
            }
        }
        
        return strategy_map.get(analysis["type"], strategy_map["generic"])

    async def get_index_routing_strategy(self, word_scores: Dict[str, int], analysis: Dict[str, Any]) -> List[str]:
        """
        D√©termine quels index prioriser selon les mots de la requ√™te
        """
        # Mots-cl√©s par index
        index_keywords = {
            "products": ["produit", "prix", "stock", "couleur", "taille", "mod√®le", "marque", "casque", "moto", "riz", "huile", "bananes"],
            "delivery": ["livraison", "zone", "d√©lai", "transport", "yopougon", "abidjan", "cocody"],
            "support_paiement": ["paiement", "support", "aide", "contact", "orange", "wave", "mobile"],
            "company": ["entreprise", "mission", "secteur", "bio", "saveurs", "afrique"],
            "location": ["adresse", "localisation", "boutique", "magasin"]
        }
        
        # Calculer les scores par index
        index_scores = {}
        for index_name, keywords in index_keywords.items():
            score = 0
            matches = 0
            for keyword in keywords:
                if keyword in word_scores:
                    score += word_scores[keyword]
                    matches += 1
            
            # Score moyen pond√©r√© par le nombre de matches
            if matches > 0:
                index_scores[index_name] = (score / matches) * (1 + matches * 0.1)
            else:
                index_scores[index_name] = 0
        
        # Trier par score d√©croissant
        sorted_indexes = sorted(index_scores.items(), key=lambda x: x[1], reverse=True)
        
        # Retourner les index avec score > 0, sinon tous
        relevant_indexes = [idx for idx, score in sorted_indexes if score > 0]
        
        return relevant_indexes if relevant_indexes else list(index_keywords.keys())


# Fonction utilitaire pour int√©gration facile
async def optimize_search_query(query: str, company_id: str, sector: str = None) -> Dict[str, Any]:
    """
    Fonction utilitaire pour optimiser une requ√™te de recherche
    """
    optimizer = HydeSearchOptimizer()
    return await optimizer.optimize_query(query, company_id, sector)


# Test rapide
if __name__ == "__main__":
    async def test_optimization():
        optimizer = HydeSearchOptimizer()
        
        # Test avec requ√™te agro-alimentaire
        result = await optimizer.optimize_query(
            "riz parfum√© 5kg livraison abidjan prix", 
            "AGR123456789", 
            "agro-alimentaire"
        )
        
        print("üéØ OPTIMISATION DE REQU√äTE")
        print("=" * 50)
        print(f"Requ√™te originale: {result['original_query']}")
        print(f"Requ√™te optimis√©e: {result['optimized_query']}")
        print(f"Type d'analyse: {result['analysis']['type']}")
        print(f"Confiance: {result['analysis']['confidence']:.1%}")
        print(f"Strat√©gie: {result['optimization_strategy']['description']}")
        
        print("\nüìä DISTRIBUTION DES SCORES:")
        for score_range, count in result['analysis']['score_distribution'].items():
            print(f"  {score_range}: {count} mots")
        
        print("\nüöÄ ACTIONS RECOMMAND√âES:")
        for action in result['optimization_strategy']['recommended_actions']:
            print(f"  ‚Ä¢ {action}")
    
    asyncio.run(test_optimization())
