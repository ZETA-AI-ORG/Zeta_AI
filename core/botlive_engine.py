import os
import easyocr
from transformers import BlipProcessor, BlipForConditionalGeneration
from PIL import Image


class BotliveEngine:
    def __init__(self):
        print("[BOTLIVE_ENGINE] Initialisation...")
        
        # Initialiser EasyOCR (fr + en pour robustesse)
        try:
            print("[BOTLIVE_ENGINE] Chargement EasyOCR...")
            self.payment_reader = easyocr.Reader(['fr', 'en'], verbose=False)
            print("[BOTLIVE_ENGINE] ‚úÖ EasyOCR charg√©")
        except Exception as e:
            print(f"[EasyOCR] ‚ùå Erreur d'initialisation: {e}")
            self.payment_reader = None

        # BLIP-2 pour captioning produits
        try:
            print("[BOTLIVE_ENGINE] Chargement BLIP-2...")
            self.blip_processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
            self.blip_model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")
            print("[BOTLIVE_ENGINE] ‚úÖ BLIP-2 charg√©")
        except Exception as e:
            print(f"[BLIP-2] ‚ùå Erreur init: {e}")
            self.blip_processor = None
            self.blip_model = None
        
        print("[BOTLIVE_ENGINE] ‚úÖ Initialisation termin√©e")

    
    def detect_product(self, image_path: str) -> dict:
        """
        Analyse une image avec BLIP-2 captioning pour description compl√®te.
        Retour: {'name': <description>, 'confidence': <0..1>}
        """
        print(f"[BLIP-2] üîç Analyse image: {image_path}")
        
        if not os.path.isfile(image_path):
            print(f"[BLIP-2] ‚ùå Fichier non trouv√©: {image_path}")
            return {"name": "image non trouv√©e", "confidence": 0.0}
        
        # BLIP-2 captioning pour description d√©taill√©e
        if self.blip_processor is None or self.blip_model is None:
            print(f"[BLIP-2] ‚ùå Mod√®le non initialis√©")
            return {"name": "mod√®le BLIP-2 indisponible", "confidence": 0.0}
        
        try:
            image = Image.open(image_path).convert('RGB')
            print(f"[BLIP-2] üì∏ Image charg√©e: {image.size}")
            
            inputs = self.blip_processor(image, return_tensors="pt")
            out = self.blip_model.generate(**inputs, max_length=50)
            caption = self.blip_processor.decode(out[0], skip_special_tokens=True)
            
            print(f"[BLIP-2] üìù Caption brut: '{caption}'")
            
            # Nettoyage l√©ger : supprimer phrases contextuelles inutiles
            stop_phrases = ["sitting on a", "on a table", "in a room", "on the floor", "on a chair"]
            cleaned_caption = caption.strip()
            for phrase in stop_phrases:
                cleaned_caption = cleaned_caption.replace(phrase, "")
            
            print(f"[BLIP-2] ‚úÖ Caption nettoy√©: '{cleaned_caption.strip()}'")
            return {"name": cleaned_caption.strip(), "confidence": 0.85}
        except Exception as e:
            print(f"[BLIP-2] ‚ùå ERREUR: {e}")
            import traceback
            traceback.print_exc()
            return {"name": "erreur analyse image", "confidence": 0.0}

    def _normalize_phone(self, phone_str: str) -> str:
        """
        Normalise un num√©ro de t√©l√©phone en retirant TOUS les caract√®res non-num√©riques.
        G√®re TOUS les formats possibles : espaces, codes pays, emojis, caract√®res sp√©ciaux, etc.
        
        Args:
            phone_str: Num√©ro brut dans N'IMPORTE QUEL format
        
        Returns:
            Num√©ro normalis√© (10 derniers chiffres uniquement) : "0787360757"
        
        Formats g√©r√©s (exemples r√©els):
            "üìû +225 07 87 36 07 57 ‚òéÔ∏è" ‚Üí "0787360757"
            "+225 07-87-36-07-57" ‚Üí "0787360757"
            "WhatsApp: 07 87 36 07 57" ‚Üí "0787360757"
            "+2250787360757" ‚Üí "0787360757"
            "0787360757" ‚Üí "0787360757"
            "Tel: üì± +225-07.87.36.07.57 ‚úÖ" ‚Üí "0787360757"
            "Contact: üí¨ 225 07 87 36 07 57" ‚Üí "0787360757"
            "07.87.36.07.57" ‚Üí "0787360757"
            
        Fonctionne pour N'IMPORTE QUEL pays:
            "+33 6 12 34 56 78" ‚Üí "0612345678" (France)
            "+1-555-123-4567" ‚Üí "5551234567" (USA)
            "üá®üáÆ +225 01 02 03 04 05" ‚Üí "0102030405" (C√¥te d'Ivoire autre)
        """
        if not phone_str:
            return ""
        
        import re
        
        # Retirer TOUS les caract√®res non-num√©riques (y compris emojis, espaces, +, -, points, etc.)
        # Garder UNIQUEMENT les chiffres
        digits_only = re.sub(r'[^\d]', '', phone_str)
        
        # Garder les 10 derniers chiffres (standard t√©l√©phone local)
        # Ignore automatiquement le code pays si pr√©sent (+225, 225, +33, +1, etc.)
        normalized = digits_only[-10:] if len(digits_only) >= 10 else digits_only
        
        return normalized
    
    def _extract_all_transactions(self, texts: list, joined: str) -> list:
        """
        Extrait toutes les transactions d'un historique (montant + num√©ro + date).
        
        Returns:
            Liste de dicts: [{'amount': '2020', 'phone': '0787360757', 'phone_normalized': '0787360757', 
                              'date': '07 oct', 'timestamp': 1696636800, 'currency': 'FCFA'}, ...]
        """
        import re
        from datetime import datetime
        
        transactions = []
        
        # Pattern pour trouver des blocs de transaction
        # Ex: "√Ä ATTIELO 07 87 36 07 57 -2.020F 07 oct , 11.17"
        transaction_patterns = [
            r'(?:√†|vers|de|au)\s+[\w\s]+?(\d{10}|\d{2}\s*\d{2}\s*\d{2}\s*\d{2}\s*\d{2})[^\d]*?[-+]?(\d{1,3}[.,]\d{3}|\d{3,5})\s*f',
            r'(\d{10}|\d{2}\s*\d{2}\s*\d{2}\s*\d{2}\s*\d{2})[^\d]*?[-+]?(\d{1,3}[.,]\d{3}|\d{3,5})\s*f',
        ]
        
        # Chercher les dates (pour timestamp)
        date_patterns = [
            r'(\d{1,2})\s+(jan|f√©v|f√©vr|mar|avr|mai|juin|juil|juill|ao√ª|ao√ªt|sep|sept|oct|nov|d√©c|dec)',
            r'(\d{1,2})/(\d{1,2})',
        ]
        
        # Extraire transactions
        text_blocks = texts  # Chaque √©l√©ment OCR
        
        # IMPORTANT: Chercher dans TOUT le texte avec une fen√™tre glissante large
        # pour g√©rer les cas o√π num√©ro et montant sont sur des lignes s√©par√©es
        for i, block in enumerate(text_blocks):
            block_lower = block.lower()
            
            # Chercher num√©ro de t√©l√©phone (patterns multiples pour robustesse)
            # G√®re: "0787360757", "07 87 36 07 57", "+225 07 87 36 07 57", "üìû +225..."
            phone_patterns = [
                r'\+?225\s*\d{2}\s*\d{2}\s*\d{2}\s*\d{2}\s*\d{2}',  # Avec code pays
                r'\d{10}',  # 10 chiffres coll√©s
                r'\d{2}\s*\d{2}\s*\d{2}\s*\d{2}\s*\d{2}',  # Avec espaces
                r'\d{2}[-\s]*\d{2}[-\s]*\d{2}[-\s]*\d{2}[-\s]*\d{2}',  # Avec tirets/espaces
            ]
            
            phone_match = None
            for pattern in phone_patterns:
                phone_match = re.search(pattern, block)
                if phone_match:
                    break
            
            if not phone_match:
                continue
            
            phone_raw = phone_match.group(0)
            phone_normalized = self._normalize_phone(phone_raw)
            
            # Chercher montant dans une LARGE fen√™tre (5 blocs avant + 5 blocs apr√®s)
            # pour g√©rer les cas o√π le texte est fragment√©
            window_start = max(0, i - 5)
            window_end = min(len(text_blocks), i + 6)
            search_text = " ".join(text_blocks[window_start:window_end]).lower()
            
            # NETTOYAGE OCR: Corriger O ‚Üí 0 dans les montants
            # "30.OOOF" ‚Üí "30.000F"
            search_text = re.sub(r'(\d+[.,])O+F', lambda m: m.group(0).replace('O', '0'), search_text, flags=re.IGNORECASE)
            search_text = re.sub(r'(\d)O(\d)', r'\g<1>0\g<2>', search_text)  # "1O2" ‚Üí "102"
            
            # IMPORTANT: Privil√©gier montants de TRANSFERT, ignorer SOLDE
            # Patterns avec contexte (transfert, vers, envoi)
            transfer_patterns = [
                # "transfert de 202.00 FCFA" OU "transfert de 2.020 FCFA" (milliers)
                # Capture TOUT : X.XXX ou XXX.XX puis on analyse apr√®s
                r'(?:transfert|envoi|paiement)\s+de\s+([-+]?\d{1,5}(?:[.,]\d{2,3})?)\s*fcfa',
                # "202 FCFA vers" ou "2.020F vers"
                r'([-+]?\d{1,5}(?:[.,]\d{2,3})?)\s*f?cfa\s+vers',
                # "vers XXX 202 FCFA"
                r'vers.*?([-+]?\d{1,5}(?:[.,]\d{2,3})?)\s*fcfa',
            ]
            
            # Patterns g√©n√©riques (fallback) - CAPTURER TOUT
            general_patterns = [
                # Format: -2.020F, 202.00 FCFA, 10.100F (avec ou sans signe)
                r'([-+]?\d{1,5}(?:[.,]\d{2,3})?)\s*f(?:cfa)?',
            ]
            
            amount = None
            
            # Fonction helper pour analyser montant
            def parse_amount(raw_amount):
                """Parse un montant en distinguant d√©cimales vs milliers"""
                # Nettoyer signes
                raw_amount = raw_amount.replace('-', '').replace('+', '').strip()
                
                # Analyser si c'est des d√©cimales ou des milliers
                # "202.00" ‚Üí d√©cimales (2 chiffres apr√®s) ‚Üí 202
                # "2.020" ‚Üí milliers (3 chiffres apr√®s) ‚Üí 2020
                # "10.100" ‚Üí milliers ‚Üí 10100
                if '.' in raw_amount or ',' in raw_amount:
                    parts = raw_amount.replace(',', '.').split('.')
                    if len(parts) == 2:
                        if len(parts[1]) == 2:
                            # D√©cimales : ignorer
                            return parts[0]
                        elif len(parts[1]) == 3:
                            # Milliers : concat√©ner
                            return parts[0] + parts[1]
                        else:
                            return parts[0]
                    else:
                        return raw_amount.replace('.', '').replace(',', '')
                else:
                    return raw_amount
            
            # D'abord chercher avec contexte de transfert
            for pattern_idx, pattern in enumerate(transfer_patterns):
                m = re.search(pattern, search_text)
                if m:
                    raw_amount = m.group(1)
                    amount = parse_amount(raw_amount)
                    
                    try:
                        amount_val = int(amount)
                        if 100 <= amount_val <= 100000:
                            amount = str(amount_val)
                            print(f"[OCR] üéØ Montant transfert d√©tect√©: {amount} FCFA (contexte: transfert/vers)")
                            break
                    except ValueError:
                        continue
            
            # Si pas trouv√© avec contexte, ignorer montants pr√®s de "solde"
            if not amount:
                # V√©rifier si "solde" est mentionn√© pr√®s du num√©ro
                if 'solde' in search_text:
                    # Ignorer ce bloc si c'est juste le solde
                    print(f"[OCR] ‚ö†Ô∏è Bloc ignor√© (solde d√©tect√©, pas de transfert)")
                    continue
                
                # Sinon utiliser patterns g√©n√©riques
                for pattern in general_patterns:
                    m = re.search(pattern, search_text)
                    if m:
                        raw_amount = m.group(1)
                        amount = parse_amount(raw_amount)
                        
                        try:
                            amount_val = int(amount)
                            if 100 <= amount_val <= 100000:
                                amount = str(amount_val)
                                break
                        except ValueError:
                            continue
            
            if not amount:
                continue
            
            # Chercher date
            date_str = ""
            timestamp = 0
            for pattern in date_patterns:
                m = re.search(pattern, search_text)
                if m:
                    date_str = m.group(0)
                    # Cr√©er timestamp approximatif (ann√©e en cours)
                    try:
                        if 'jan' in date_str or 'f√©v' in date_str or 'mar' in date_str:
                            timestamp = 100000000 + int(m.group(1)) * 86400
                        elif 'avr' in date_str or 'mai' in date_str or 'juin' in date_str:
                            timestamp = 200000000 + int(m.group(1)) * 86400
                        elif 'juil' in date_str or 'ao√ª' in date_str or 'sep' in date_str:
                            timestamp = 300000000 + int(m.group(1)) * 86400
                        else:  # oct, nov, dec
                            timestamp = 400000000 + int(m.group(1)) * 86400
                    except:
                        timestamp = 0
                    break
            
            # Ajouter transaction
            transactions.append({
                'amount': amount,
                'phone': phone_raw,
                'phone_normalized': phone_normalized,
                'date': date_str,
                'timestamp': timestamp,
                'currency': 'FCFA'
            })
        
        # D√©dupliquer (m√™me montant + m√™me num√©ro)
        seen = set()
        unique_transactions = []
        for t in transactions:
            key = f"{t['amount']}_{t['phone_normalized']}"
            if key not in seen:
                seen.add(key)
                unique_transactions.append(t)
        
        return unique_transactions

    def verify_payment(self, image_path: str, company_phone: str = None) -> dict:
        """
        OCR pour extraire montant/devise, avec VALIDATION STRICTE du num√©ro entreprise.
        
        Args:
            image_path: Chemin vers l'image
            company_phone: Num√©ro de t√©l√©phone de l'entreprise (OBLIGATOIRE pour validation)
        
        Returns:
            Dict avec amount, currency, reference, raw_text, et transactions si multiples
            Retourne vide si num√©ro entreprise absent de l'image
        """
        out = {"amount": "", "currency": "", "reference": "", "raw_text": "", "all_transactions": [], "error": ""}
        if self.payment_reader is None or not os.path.isfile(image_path):
            return out
        try:
            results = self.payment_reader.readtext(image_path, detail=1)
            texts = [r[1] for r in results if len(r) > 1]
            out["raw_text"] = " \n".join(texts)

            import re
            from datetime import datetime
            joined = " ".join(t.lower() for t in texts)
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # VALIDATION STRICTE #1 : NUM√âRO ENTREPRISE OBLIGATOIRE
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            normalized_company_phone = None
            if company_phone:
                normalized_company_phone = self._normalize_phone(company_phone)
                if normalized_company_phone:
                    print(f"[OCR] üéØ Validation stricte pour num√©ro: {normalized_company_phone}")
                    print(f"[OCR] üì± Format original: {company_phone}")
                    
                    # V√âRIFIER que le num√©ro entreprise est dans l'image
                    phone_found = False
                    for text_block in texts:
                        normalized_block = self._normalize_phone(text_block)
                        if normalized_block and normalized_company_phone in normalized_block:
                            phone_found = True
                            print(f"[OCR] ‚úÖ Num√©ro entreprise trouv√© dans l'image")
                            break
                    
                    if not phone_found:
                        print(f"[OCR] ‚ùå REJET STRICT: Num√©ro entreprise ABSENT de l'image")
                        print(f"[OCR] üö´ Capture invalide - num√©ro {normalized_company_phone} non d√©tect√©")
                        out["error"] = "NUMERO_ABSENT"
                        return out
                else:
                    print(f"[OCR] ‚ö†Ô∏è Impossible d'extraire num√©ro de: {company_phone}")
            
            # √âTAPE 1: Extraire toutes les transactions (montant + num√©ro + date)
            all_transactions = self._extract_all_transactions(texts, joined)
            
            if all_transactions:
                print(f"[OCR] üìã {len(all_transactions)} transactions d√©tect√©es")
                for t in all_transactions[:3]:
                    print(f"     ‚Üí {t['amount']}F vers {t.get('phone', 'N/A')} le {t.get('date', 'N/A')}")
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # √âTAPE 2: Filtrer par num√©ro (OBLIGATOIRE)
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if normalized_company_phone and all_transactions:
                filtered = [t for t in all_transactions if t.get('phone_normalized') == normalized_company_phone]
                
                if filtered:
                    print(f"[OCR] ‚úÖ {len(filtered)} transaction(s) vers num√©ro entreprise")
                    # Trier par date (plus r√©cent en premier)
                    filtered_sorted = sorted(filtered, key=lambda x: x.get('timestamp', 0), reverse=True)
                    best_transaction = filtered_sorted[0]
                    
                    out["amount"] = best_transaction['amount']
                    out["currency"] = best_transaction.get('currency', 'FCFA')
                    out["reference"] = best_transaction.get('reference', '')
                    out["all_transactions"] = all_transactions
                    
                    print(f"[OCR] üéØ Transaction s√©lectionn√©e: {out['amount']} FCFA (la plus r√©cente)")
                    
                    r = re.search(r"(ref[:\-\s]*[a-z0-9\-]+|wave[:\-\s]*[a-z0-9\-]+)", joined)
                    if r:
                        out["reference"] = r.group(1).upper()
                    
                    return out
                else:
                    print(f"[OCR] ‚ùå REJET STRICT: Aucune transaction vers {normalized_company_phone}")
                    print(f"[OCR] üö´ Num√©ro trouv√© mais pas de transaction valide associ√©e")
                    out["error"] = "TRANSACTION_ABSENTE"
                    return out
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # VALIDATION STRICTE #2 : Si company_phone fourni mais pas de transaction ‚Üí REJETER
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if normalized_company_phone and not all_transactions:
                print(f"[OCR] ‚ùå REJET STRICT: Num√©ro fourni mais aucune transaction d√©tect√©e")
                print(f"[OCR] üö´ Image invalide - capture floue ou incompl√®te")
                out["error"] = "CAPTURE_INVALIDE"
                return out
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # √âTAPE 3: Fallback UNIQUEMENT si company_phone NON fourni
            # (Mode legacy pour compatibilit√© backward)
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if normalized_company_phone:
                # Si on arrive ici avec company_phone fourni, c'est une erreur
                print(f"[OCR] ‚ùå REJET STRICT: Validation √©chou√©e")
                out["error"] = "VALIDATION_ECHOUEE"
                return out
            
            print(f"[OCR] ‚ö†Ô∏è Mode legacy: company_phone non fourni, validation rel√¢ch√©e")
            
            # Patterns multiples pour robustesse (ordre de priorit√©)
            # IMPORTANT: Pour √©viter de transformer 202.00 en 20200, on ignore les d√©cimales
            patterns = [
                # Format avec d√©cimales: 202.00 FCFA ‚Üí on prend juste 202 (partie enti√®re)
                r"(\d{3,5})(?:[.,]\d{1,2})?\s*fcfa",
                # Format Wave/Orange: -2.020F (milliers avec point) ‚Üí -2020
                r"-\s*(\d{1,2})[.,](\d{3})\s*f(?:\s|$|\.)",
                # Montant avec s√©parateurs + F: 10.100F ‚Üí 10100
                r"(\d{1,3})[.,](\d{3})\s*f(?:\s|$|\.)",
                # Montant 3-5 chiffres + F seul
                r"-?\s*(\d{3,5})\s*f(?:\s|$|\.)",
                # Montant pr√®s de mots-cl√©s
                r"(?:montant|total|somme|paiement)[:\s]*-?\s*(\d{1,5})",
                # Juste un nombre 3-5 chiffres (dernier recours)
                r"(?<!\d)(\d{3,5})(?!\d)"
            ]
            
            candidates = []
            
            # Trouver tous les candidats
            for priority, pattern in enumerate(patterns):
                for m in re.finditer(pattern, joined):
                    # G√©rer patterns selon leur structure
                    currency = ''
                    
                    if priority == 0:  # Pattern: XXX.XX FCFA (ignore d√©cimales, 1 groupe)
                        amount_str = m.group(1)
                        currency = 'FCFA'
                    elif priority in [1, 2]:  # Patterns: X.XXXF (2 groupes pour reconstituer milliers)
                        # Reconstituer le montant: "2" + "020" = "2020"
                        amount_str = m.group(1) + m.group(2)
                    else:  # Patterns 3, 4, 5: juste le montant (1 groupe)
                        amount_str = m.group(1)
                    
                    amount_str = amount_str.replace(',', '.').replace(' ', '').replace('o', '0').replace('O', '0')
                    
                    try:
                        amount_val = abs(float(amount_str))  # Valeur absolue pour g√©rer les n√©gatifs
                        # Filtrer montants r√©alistes (50 √† 100000)
                        if 50 <= amount_val <= 100000:
                            candidates.append({
                                'amount': str(int(amount_val)),
                                'currency': currency.replace('XOF', 'FCFA').replace('F CFA', 'FCFA'),
                                'priority': priority,
                                'value': amount_val
                            })
                    except (ValueError, AttributeError, IndexError):
                        continue
            
            # Choisir le meilleur candidat
            if candidates:
                # Chercher num√©ro entreprise dans le texte (0787360757 ou variantes)
                company_number_patterns = [
                    r'0787360757', r'07\s*87\s*36\s*07\s*57', 
                    r'\+225\s*07\s*87\s*36\s*07\s*57'
                ]
                
                has_company_number = any(re.search(p, joined) for p in company_number_patterns)
                
                # Si num√©ro entreprise pr√©sent, privil√©gier montants entre 1000-5000 (paiements typiques)
                if has_company_number:
                    # Chercher mention de transfert/paiement VERS ce num√©ro
                    # IMPORTANT: Extraire montant AVANT le num√©ro ou juste apr√®s "transfert de XXX vers"
                    payment_to_company_patterns = [
                        # "transfert de 202.00 FCFA vers" ‚Üí groupe 1 = partie enti√®re, groupe 2 = d√©cimales
                        r'(?:transfert|envoi|paiement)\s+de\s+(\d{1,5})(?:[.,](\d{1,2}))?\s*fcfa\s+vers',
                        # "202 FCFA vers 0787360757" (avant le num√©ro)
                        r'(\d{3,5})\s*fcfa\s+vers\s+(?:le\s+)?0787360757',
                    ]
                    
                    targeted_amount = None
                    for pattern_idx, pattern in enumerate(payment_to_company_patterns):
                        m = re.search(pattern, joined)
                        if m:
                            try:
                                # Pour pattern avec d√©cimales : ignorer les d√©cimales
                                if pattern_idx == 0 and len(m.groups()) >= 2 and m.group(2):
                                    # "202.00" ‚Üí on garde juste "202" (partie enti√®re)
                                    amount_str = m.group(1)
                                else:
                                    amount_str = m.group(1)
                                
                                targeted_amount = int(amount_str)
                                if 100 <= targeted_amount <= 100000:
                                    # V√©rifier que ce n'est PAS un solde
                                    # Chercher "solde" dans les 50 caract√®res AVANT ce montant
                                    match_pos = m.start()
                                    context_before = joined[max(0, match_pos - 50):match_pos]
                                    if 'solde' not in context_before:
                                        print(f"[OCR] üéØ Transaction cibl√©e vers entreprise d√©tect√©e: {targeted_amount} FCFA")
                                        break
                                    else:
                                        print(f"[OCR] ‚ö†Ô∏è Montant {targeted_amount} ignor√© (contexte: solde)")
                                        targeted_amount = None
                            except (ValueError, AttributeError):
                                continue
                    
                    # Si montant cibl√© trouv√©, le prioriser
                    if targeted_amount:
                        for c in candidates:
                            if abs(int(c['amount']) - targeted_amount) < 10:
                                best = c
                                print(f"[OCR] ‚úÖ Montant cibl√© s√©lectionn√©: {best['amount']} FCFA")
                                break
                        else:
                            # Sinon, privil√©gier montants typiques de d√©p√¥t (1500-3000)
                            typical_deposits = [c for c in candidates if 1500 <= c['value'] <= 3000]
                            best = typical_deposits[0] if typical_deposits else sorted(candidates, key=lambda x: (x['priority'], abs(x['value'] - 2000)))[0]
                            print(f"[OCR] ‚úÖ Montant typique s√©lectionn√©: {best['amount']} FCFA")
                    else:
                        # Privil√©gier montants typiques (1500-3000 FCFA)
                        typical_deposits = [c for c in candidates if 1500 <= c['value'] <= 3000]
                        best = typical_deposits[0] if typical_deposits else sorted(candidates, key=lambda x: (x['priority'], abs(x['value'] - 2000)))[0]
                        print(f"[OCR] ‚ö†Ô∏è S√©lection montant typique (1500-3000): {best['amount']} FCFA")
                else:
                    # Pas de num√©ro entreprise : trier normal
                    best = sorted(candidates, key=lambda x: (x['priority'], -1 if x['value'] >= 1000 else 1, -x['value']))[0]
                
                out["amount"] = best['amount']
                out["currency"] = best['currency'] if best['currency'] else ('FCFA' if any(k in joined for k in ['fcfa', 'xof', 'cfa', 'f ']) else '')
                
                # Debug: afficher tous les candidats
                if len(candidates) > 1:
                    print(f"[OCR] {len(candidates)} montants d√©tect√©s, choisi: {best['amount']} FCFA (priorit√© {best['priority']})")
                    others = [f"{c['amount']}F (p{c['priority']})" for c in candidates[:5]]
                    print(f"[OCR] Autres candidats: {others}")
            elif any(k in joined for k in ['fcfa', 'xof', 'cfa']):
                out["currency"] = 'FCFA'
            r = re.search(r"(ref[:\-\s]*[a-z0-9\-]+|wave[:\-\s]*[a-z0-9\-]+)", joined)
            if r:
                out["reference"] = r.group(1).upper()
            return out
        except Exception as e:
            print(f"[EasyOCR][ERREUR] {e}")
            return out
    
    def process_live_order(self, product_img_path: str, payment_img_path: str) -> str:
        """
        Traite une commande: d√©tection produit + OCR paiement, puis renvoie un message court (sans LLM).
        """
        product = self.detect_product(product_img_path)
        payment = self.verify_payment(payment_img_path)

        label = product.get('name', 'inconnu')
        conf = product.get('confidence', 0.0)
        amount = payment.get('amount', '')
        currency = payment.get('currency', '') or 'FCFA'
        ref = payment.get('reference', '')

        parts = []
        parts.append(f"üõí Produit d√©tect√©: {label} ({conf*100:.1f}%).")
        if amount:
            parts.append(f"üí≥ Paiement: {amount} {currency}.")
        else:
            parts.append("üí≥ Paiement d√©tect√©: montant non lisible.")
        if ref:
            parts.append(f"R√©f√©rence: {ref}.")

        return " ".join(parts)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SINGLETON CACHE - √âvite de recharger les mod√®les √† chaque requ√™te
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

_botlive_engine_instance = None

def get_botlive_engine() -> BotliveEngine:
    """
    Retourne une instance singleton de BotliveEngine.
    Les mod√®les BLIP-2 et EasyOCR ne sont charg√©s qu'une seule fois.
    """
    global _botlive_engine_instance
    if _botlive_engine_instance is None:
        print("[SINGLETON] Premi√®re initialisation BotliveEngine...")
        _botlive_engine_instance = BotliveEngine()
        print("[SINGLETON] ‚úÖ Instance cr√©√©e et cach√©e")
    return _botlive_engine_instance

# Exemple d'utilisation
if __name__ == "__main__":
    engine = get_botlive_engine()  # Premi√®re fois: charge les mod√®les
    product_img = "path/to/product.jpg"
    payment_img = "path/to/payment.jpg"
    result = engine.process_live_order(product_img, payment_img)
    print("Confirmation de commande:", result)
    
    # Appels suivants: r√©utilise l'instance cach√©e
    engine2 = get_botlive_engine()  # Instant, pas de rechargement
    print("M√™me instance:", engine is engine2)  # True
